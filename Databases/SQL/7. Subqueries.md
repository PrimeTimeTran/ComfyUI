## Subqueries

### 1978. Employees Whose Manager Left the Company

- Self Join
- Use `NOT IN` to compare manager_id to employee_id.
  ```sql
		SELECT e.employee_id
		FROM Employees e
		WHERE e.salary < 30000
		AND e.manager_id NOT IN (
		SELECT m.employee_id
		FROM Employees m)
		GROUP BY e.employee_id
		ORDER BY e.employee_id
	```

### 626. Exchange Seats

- Use window `ROW_NUMBER` & `OVER` to generate row numbers
- Use `ORDER BY` to swap seats of each row with `IF`.
- Use `MOD` to swap on id.
	- Swap evens & odds.
  ```sql
		SELECT ROW_NUMBER() OVER() id, student
		FROM seat
		ORDER BY IF(MOD(id, 2) = 0, id-1, id+1)
	```

### 1341. Movie Rating

- `UNION` two `SELECT`.
- Use `()` around the each `SELECT`.
- `USING` is like `ON` but must wrap the field with `()`
  ```sql
		(select name as results
		from users
		join movierating
		on users.user_id = movierating.user_id
		group by name
		having count(movierating.user_id)
		order by count(*) desc, name
		limit 1)
		
		union all
		
		(select title as results from movierating
		join movies using(movie_id)
		WHERE EXTRACT(YEAR_MONTH FROM created_at) = 202002
		group by title
		order by avg(rating) desc, title
		limit 1)
	```

### 1321. Restaurant Growth

- Select intervals greater than the min of the lowest interval, 7 days.
- Calculate *amount* using subquery on *visited_on* field.
- Use `DATE_SUB` to 
  ```sql
		SELECT
		visited_on,
		(
			SELECT SUM(amount)
			FROM customer
			WHERE visited_on BETWEEN DATE_SUB(c.visited_on, INTERVAL 6 DAY) AND c.visited_on
		) AS amount,
		ROUND(
		(
			SELECT SUM(amount) / 7
			FROM customer
			WHERE visited_on BETWEEN DATE_SUB(c.visited_on, INTERVAL 6 DAY) AND c.visited_on
		),
		2
		) AS average_amount
		FROM customer c
		WHERE visited_on >= (
			SELECT DATE_ADD(MIN(visited_on), INTERVAL 6 DAY)
			FROM customer
		)
		GROUP BY visited_on;
	```

### 602. Friend Requests II: Who Has The Most Friends Requests
- `UNION ALL` requester & accepter.
- Use CTE to create table to make subsequent query on.
- Query *id* & *count* from CTE `GROUP BY` *id* and `ORDER BY` *count* `DESC` & `LIMIT` to 1 to meet requirements.
  ```sql
		with base as (select requester_id id from requestaccepted
		union all
		select accepter_id id from requestaccepted)
		select id, count(*) num from base group by 1 order by 2 desc limit 1
	```
### 585. Investments in 2016

- `PARTITION` to select from those who have 2015 investment accounts.
- `SELECT` rows that have 2 or more matching records for field CTN1, windows where there are more than 1 matching record in the window over the query.
	- `COUNT` results
- `PARTITION` to select lat & lon from table.
- `SELECT` rows which have CTN2 of 1, which means they don't have any matching lat & lon records to compete against.
	- `COUNT` results

  ```sql
		SELECT ROUND(SUM(TIV_2016),2) AS TIV_2016
		FROM
		(SELECT *,
			COUNT(*) OVER(PARTITION BY TIV_2015) AS CNT1,
			COUNT(*) OVER(PARTITION BY LAT, LON) AS CNT2
			FROM INSURANCE
		) AS TBL
		WHERE CNT1 >= 2 AND CNT2 = 1
	```
### 185. Department Top Three Salaries

- Subquery for employees with higher salaries than the outer query employee
- Return users who have less than 3 employees that have greater salary than them in their department.
  ```sql
		select department.name department, e1.name employee, salary
		from employee e1
		join department
		on e1.departmentId = department.id
		where 3 > (
			select count(distinct e2.salary)
			from employee e2
			where e2.salary > e1.salary
			and e1.departmentId = e2.departmentId
		)
	```
