## Why

https://docs.modular.com/engine/python/get-started
https://github.com/HigherOrderCO/Bend?tab=readme-ov-file

## Intro

## Study GCC/G++ Compiler

Let's study another compiler to understand some of the steps involved.

- Write code

  ```
  int main() {
      return 1;
  }
  ```

  We're going to use C++ because it's ubiquitous.

- Create assembly file(machine code) from the `C` code.
  `g++ -S -O3 -fno-asynchronous-unwind-tables one.cpp`

  The literal instructions the processor will follow can be viewed with.
  `cat one.s`

  A `.s` file typically refers to a source file written in assembly language. Assembly language is a low-level programming language that is closely tied to the machine code instructions understood by a specific computer architecture's processor.

  When you write code in assembly language, you are essentially writing human-readable representations of the instructions that the processor will execute. These instructions are typically very basic and correspond directly to the operations that the processor can perform.

  Assembly language source files are usually human-readable and contain instructions such as moving data between registers, performing arithmetic operations, and controlling program flow. These files are then assembled by an assembler, a program that translates assembly language code into machine code instructions that the processor can execute directly.

  Once assembled, the result is often an object file (`.o` file) which contains the machine code instructions. This object file can then be linked with other object files and libraries to create an executable program.

  Programs written in assembly language are often used in situations where performance or low-level control over hardware is critical, such as in operating system development, device drivers, or embedded systems programming.

- Create binary source file
  `as one.s -o one.o`

  Computers read binary so we need to compile the assembly to binary.

  We want to build the binary because this will be used with a linker

  A .o file, also known as an object file, is a compiled file generated by a compiler during the compilation of a source code file. When you compile a program written in a programming language like C or C++, the compiler translates the human-readable source code into machine code that the computer can understand. This process typically involves several steps, one of which is compiling individual source code files into object files.

  Object files contain machine code instructions, symbols, and other data necessary for the program to run. They are not directly executable but rather serve as an intermediate step in the compilation process. After all the necessary source code files have been compiled into object files, they are typically linked together by a linker to create an executable file.

  Object files have different extensions depending on the platform and compiler used. For example, on Unix-like systems, they often have a .o extension, while on Windows, they might have a .obj extension.

- Link binary
  `g++ one.o -o my_program`

  Now we've created an executable, a file which will "run"

- Run program
  `./one`

  Running it should also produce nothing. View the program output with
  `echo $?`

Pat yourself on the back, you now understand the MVP compile process

### Conclusion

We've observed how compilers are a multi step process. Going from a high level language such as C++ to low level machine readable binary
includes several processes.

## Lexer

In a real-world scenario, building a complete compiler involves several additional steps beyond compiling a single source file into assembly and then into an object file. You'll typically need to implement a lexer, parser, semantic analyzer, code generator, and possibly other components depending on the complexity of the language you're compiling. You'll also need to handle linking multiple object files together and generating an executable binary.

- Define tokens
  `token_map.csv`

  Python will use this to understand what constitutes a token.

- Use python to create a lexer.
  `touch lexer.py tokenizer.py`

  This will be responsible for

- Identify the tokens
  `python tokenizer.py ./one.cpp`

Great! If your semantic analysis step is completed without errors, you can proceed with the next steps in your compiler pipeline. Here's an overview of what typically comes next after semantic analysis:

1. **Intermediate Representation (IR) Generation**: Convert the high-level language code (e.g., C++) into an intermediate representation (IR), which is closer to machine code but still human-readable. This IR serves as a common ground for optimization and code generation.

2. **Optimization**: Apply various optimization techniques to improve the efficiency of the code. This step can involve analyzing the IR and applying transformations to make the code faster, smaller, or use less memory.

3. **Code Generation**: Translate the IR into low-level machine code or assembly language suitable for execution on a specific target platform (e.g., x86, ARM). This involves mapping high-level constructs to machine-level instructions and managing registers, memory, and control flow.

4. **Assembly or Object Code Generation**: Generate assembly language code or object files (binary code) from the machine code. These files can then be linked together with other object files and libraries to produce an executable program.

5. **Linking**: If your compiler generates object files, you'll need a linker to combine them into a single executable program. The linker resolves references between different parts of the code, including function calls and variable accesses.

6. **Executable Output**: Finally, you'll have a complete executable program that can be run on the target platform. This program will contain the compiled and optimized code generated by your compiler.

Depending on the complexity of your compiler and the features you want to support, you may need to implement additional steps or refine the existing ones. Each of these steps can involve its own set of challenges and optimizations, so it's essential to plan and design your compiler pipeline carefully.

## Resources

- https://github.com/JonathanPierce/PyTokenize
